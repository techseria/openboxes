import { PureComponent, createElement } from 'react';
import PropTypes from 'prop-types';
import { fieldSubscriptionItems, version, ARRAY_ERROR } from 'final-form';
import { version as version$1 } from 'react-final-form';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

function componentWillMount() {
  // Call this.constructor.gDSFP to support sub-classes.
  var state = this.constructor.getDerivedStateFromProps(this.props, this.state);
  if (state !== null && state !== undefined) {
    this.setState(state);
  }
}

function componentWillReceiveProps(nextProps) {
  // Call this.constructor.gDSFP to support sub-classes.
  // Use the setState() updater to ensure state isn't stale in certain edge cases.
  function updater(prevState) {
    var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);
    return state !== null && state !== undefined ? state : null;
  }
  // Binding "this" is important for shallow renderer support.
  this.setState(updater.bind(this));
}

function componentWillUpdate(nextProps, nextState) {
  try {
    var prevProps = this.props;
    var prevState = this.state;
    this.props = nextProps;
    this.state = nextState;
    this.__reactInternalSnapshotFlag = true;
    this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(
      prevProps,
      prevState
    );
  } finally {
    this.props = prevProps;
    this.state = prevState;
  }
}

// React may warn about cWM/cWRP/cWU methods being deprecated.
// Add a flag to suppress these warnings for this special case.
componentWillMount.__suppressDeprecationWarning = true;
componentWillReceiveProps.__suppressDeprecationWarning = true;
componentWillUpdate.__suppressDeprecationWarning = true;

function polyfill(Component) {
  var prototype = Component.prototype;

  if (!prototype || !prototype.isReactComponent) {
    throw new Error('Can only polyfill class components');
  }

  if (
    typeof Component.getDerivedStateFromProps !== 'function' &&
    typeof prototype.getSnapshotBeforeUpdate !== 'function'
  ) {
    return Component;
  }

  // If new component APIs are defined, "unsafe" lifecycles won't be called.
  // Error if any of these lifecycles are present,
  // Because they would work differently between older and newer (16.3+) versions of React.
  var foundWillMountName = null;
  var foundWillReceivePropsName = null;
  var foundWillUpdateName = null;
  if (typeof prototype.componentWillMount === 'function') {
    foundWillMountName = 'componentWillMount';
  } else if (typeof prototype.UNSAFE_componentWillMount === 'function') {
    foundWillMountName = 'UNSAFE_componentWillMount';
  }
  if (typeof prototype.componentWillReceiveProps === 'function') {
    foundWillReceivePropsName = 'componentWillReceiveProps';
  } else if (typeof prototype.UNSAFE_componentWillReceiveProps === 'function') {
    foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';
  }
  if (typeof prototype.componentWillUpdate === 'function') {
    foundWillUpdateName = 'componentWillUpdate';
  } else if (typeof prototype.UNSAFE_componentWillUpdate === 'function') {
    foundWillUpdateName = 'UNSAFE_componentWillUpdate';
  }
  if (
    foundWillMountName !== null ||
    foundWillReceivePropsName !== null ||
    foundWillUpdateName !== null
  ) {
    var componentName = Component.displayName || Component.name;
    var newApiName =
      typeof Component.getDerivedStateFromProps === 'function'
        ? 'getDerivedStateFromProps()'
        : 'getSnapshotBeforeUpdate()';

    throw Error(
      'Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n' +
        componentName +
        ' uses ' +
        newApiName +
        ' but also contains the following legacy lifecycles:' +
        (foundWillMountName !== null ? '\n  ' + foundWillMountName : '') +
        (foundWillReceivePropsName !== null
          ? '\n  ' + foundWillReceivePropsName
          : '') +
        (foundWillUpdateName !== null ? '\n  ' + foundWillUpdateName : '') +
        '\n\nThe above lifecycles should be removed. Learn more about this warning here:\n' +
        'https://fb.me/react-async-component-lifecycle-hooks'
    );
  }

  // React <= 16.2 does not support static getDerivedStateFromProps.
  // As a workaround, use cWM and cWRP to invoke the new static lifecycle.
  // Newer versions of React will ignore these lifecycles if gDSFP exists.
  if (typeof Component.getDerivedStateFromProps === 'function') {
    prototype.componentWillMount = componentWillMount;
    prototype.componentWillReceiveProps = componentWillReceiveProps;
  }

  // React <= 16.2 does not support getSnapshotBeforeUpdate.
  // As a workaround, use cWU to invoke the new lifecycle.
  // Newer versions of React will ignore that lifecycle if gSBU exists.
  if (typeof prototype.getSnapshotBeforeUpdate === 'function') {
    if (typeof prototype.componentDidUpdate !== 'function') {
      throw new Error(
        'Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype'
      );
    }

    prototype.componentWillUpdate = componentWillUpdate;

    var componentDidUpdate = prototype.componentDidUpdate;

    prototype.componentDidUpdate = function componentDidUpdatePolyfill(
      prevProps,
      prevState,
      maybeSnapshot
    ) {
      // 16.3+ will not execute our will-update method;
      // It will pass a snapshot value to did-update though.
      // Older versions will require our polyfilled will-update value.
      // We need to handle both cases, but can't just check for the presence of "maybeSnapshot",
      // Because for <= 15.x versions this might be a "prevContext" object.
      // We also can't just check "__reactInternalSnapshot",
      // Because get-snapshot might return a falsy value.
      // So check for the explicit __reactInternalSnapshotFlag flag to determine behavior.
      var snapshot = this.__reactInternalSnapshotFlag
        ? this.__reactInternalSnapshot
        : maybeSnapshot;

      componentDidUpdate.call(this, prevProps, prevState, snapshot);
    };
  }

  return Component;
}

//      
function diffSubscription (a, b, keys) {
  if (a) {
    if (b) {
      // $FlowFixMe
      return keys.some(function (key) {
        return a[key] !== b[key];
      });
    } else {
      return true;
    }
  } else {
    return !!b;
  }
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

//      

// shared logic between components that use either render prop,
// children render function, or component prop
function renderComponent(props, name) {
  var render = props.render,
      children = props.children,
      component = props.component,
      rest = objectWithoutProperties(props, ['render', 'children', 'component']);

  if (component) {
    return createElement(component, _extends({}, rest, { children: children })); // inject children back in
  }
  if (render) {
    return render(_extends({}, rest, { children: children })); // inject children back in
  }
  // istanbul ignore next
  if (typeof children !== 'function') {
    if (process.env.NODE_ENV !== 'production') {
      console.error('Warning: Must specify either a render prop, a render function as children, or a component prop to ' + name);
      return null; // warning will alert developer to their mistake
    }
  }
  return children(rest);
}

//      
var version$2 = '1.0.6';

var versions = {
  'final-form': version,
  'react-final-form': version$1,
  'react-final-form-arrays': version$2
};

var all = fieldSubscriptionItems.reduce(function (result, key) {
  result[key] = true;
  return result;
}, {});

var FieldArray = function (_React$PureComponent) {
  inherits(FieldArray, _React$PureComponent);

  function FieldArray(props, context) {
    classCallCheck(this, FieldArray);

    var _this = possibleConstructorReturn(this, (FieldArray.__proto__ || Object.getPrototypeOf(FieldArray)).call(this, props, context));

    _initialiseProps.call(_this);

    var initialState = void 0;
    // istanbul ignore next
    if (process.env.NODE_ENV !== 'production' && !context.reactFinalForm) {
      console.error('Warning: FieldArray must be used inside of a ReactFinalForm component');
    }
    var reactFinalForm = _this.context.reactFinalForm;

    if (reactFinalForm) {
      // avoid error, warning will alert developer to their mistake
      _this.subscribe(props, function (state) {
        if (initialState) {
          _this.notify(state);
        } else {
          initialState = state;
        }
      });
    }
    _this.state = { state: initialState };
    _this.bindMutators(props);
    _this.mounted = false;
    return _this;
  }

  createClass(FieldArray, [{
    key: 'UNSAFE_componentWillReceiveProps',
    value: function UNSAFE_componentWillReceiveProps(nextProps) {
      var name = nextProps.name,
          subscription = nextProps.subscription;

      if (this.props.name !== name || diffSubscription(this.props.subscription, subscription, fieldSubscriptionItems)) {
        if (this.context.reactFinalForm) {
          // avoid error, warning will alert developer to their mistake
          this.unsubscribe();
          this.subscribe(nextProps, this.notify);
        }
      }
      if (this.props.name !== name) {
        this.bindMutators(nextProps);
      }
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.mounted = true;
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.mounted = false;
      this.unsubscribe();
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          name = _props.name,
          rest = objectWithoutProperties(_props, ['name']);

      var _ref = this.state.state || {},
          length = _ref.length,
          active = _ref.active,
          dirty = _ref.dirty,
          error = _ref.error,
          initial = _ref.initial,
          invalid = _ref.invalid,
          pristine = _ref.pristine,
          submitError = _ref.submitError,
          submitFailed = _ref.submitFailed,
          submitSucceeded = _ref.submitSucceeded,
          touched = _ref.touched,
          valid = _ref.valid,
          visited = _ref.visited,
          fieldStateFunctions = objectWithoutProperties(_ref, ['length', 'active', 'dirty', 'error', 'initial', 'invalid', 'pristine', 'submitError', 'submitFailed', 'submitSucceeded', 'touched', 'valid', 'visited']);

      var meta = {
        active: active,
        dirty: dirty,
        error: error,
        initial: initial,
        invalid: invalid,
        pristine: pristine,
        submitError: submitError,
        submitFailed: submitFailed,
        submitSucceeded: submitSucceeded,
        touched: touched,
        valid: valid,
        visited: visited
      };
      var fieldState = _extends({}, meta, fieldStateFunctions);
      return renderComponent(_extends({
        fields: _extends({
          name: name,
          forEach: this.forEach,
          length: length,
          map: this.map
        }, this.mutators, fieldState),
        meta: meta
      }, rest, {
        __versions: versions
      }), 'FieldArray(' + name + ')');
    }
  }]);
  return FieldArray;
}(PureComponent);

FieldArray.displayName = 'ReactFinalFormFieldArray(' + version + ')(' + version$2 + ')';

var _initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this.subscribe = function (_ref2, listener) {
    var name = _ref2.name,
        subscription = _ref2.subscription;

    _this2.unsubscribe = _this2.context.reactFinalForm.registerField(name, listener, subscription ? _extends({}, subscription, { length: true }) : all, {
      getValidator: function getValidator() {
        return _this2.validate;
      }
    });
  };

  this.validate = function () {
    var validate = _this2.props.validate;

    if (!validate) return undefined;
    var error = validate.apply(undefined, arguments);
    if (!error || Array.isArray(error)) {
      return error;
    } else {
      var arrayError = []
      // gross, but we have to set a string key on the array
      ;arrayError[ARRAY_ERROR] = error;
      return arrayError;
    }
  };

  this.bindMutators = function (_ref3) {
    var name = _ref3.name;
    var reactFinalForm = _this2.context.reactFinalForm;

    if (reactFinalForm) {
      var mutators = reactFinalForm.mutators;

      var hasMutators = !!(mutators && mutators.push && mutators.pop);
      // istanbul ignore next
      if (process.env.NODE_ENV !== 'production' && !hasMutators) {
        console.error('Warning: Array mutators not found. You need to provide the mutators from final-form-arrays to your form');
      }
      if (hasMutators) {
        _this2.mutators = Object.keys(mutators).reduce(function (result, key) {
          result[key] = function () {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            return mutators[key].apply(mutators, [name].concat(args));
          };
          return result;
        }, {});
      }
    }
  };

  this.notify = function (state) {
    setTimeout(function () {
      if (_this2.mounted) {
        _this2.setState({ state: state });
      }
    });
  };

  this.forEach = function (iterator) {
    var name = _this2.props.name;
    // required || for Flow, but results in uncovered line in Jest/Istanbul
    // istanbul ignore next

    var length = _this2.state.state ? _this2.state.state.length || 0 : 0;
    for (var i = 0; i < length; i++) {
      iterator(name + '[' + i + ']', i);
    }
  };

  this.map = function (iterator) {
    var name = _this2.props.name;
    // required || for Flow, but results in uncovered line in Jest/Istanbul
    // istanbul ignore next

    var length = _this2.state.state ? _this2.state.state.length || 0 : 0;
    var results = [];
    for (var i = 0; i < length; i++) {
      results.push(iterator(name + '[' + i + ']', i));
    }
    return results;
  };
};

FieldArray.contextTypes = {
  reactFinalForm: PropTypes.object
};

polyfill(FieldArray);

//

export { FieldArray, version$2 as version };
